## Solution

- Using Unordered-Map and Min-Heap:
    - Code:
        ```cpp
        bool isNStraightHand(vector<int>& hand, int groupSize) {
            if(hand.size() % groupSize != 0)
                return false;
            priority_queue<int, vector<int>, greater<int>> minHeap;
            unordered_map<int, int> freq;
            for(int h: hand) {
                freq[h]++;
                if(freq[h] == 1)
                    minHeap.push(h);
            }
            while(!minHeap.empty()) {
                int j = minHeap.top();
                for(int i = 0; i < groupSize; ++i) {
                    if(freq[j] == 0)
                        return false;
                    freq[j]--;
                    if(j == minHeap.top() && freq[j] == 0)
                        minHeap.pop();
                    j++;
                }
            }
            return true;
        }
        ```
    - TC: $O(nlogn)$
    - SC: $O(n)$

- Using Ordered Map
    - Code:
        ```cpp
        bool isNStraightHand(vector<int>& hand, int groupSize) {
            if(hand.size() % groupSize != 0)
                return false;
            map<int, int> freq;
            for(int h: hand) {
                freq[h]++;
            }
            while(!freq.empty()) {
                int mini = freq.begin()->first;
                for(int i = 0; i < groupSize; ++i) {
                    if(freq[mini+i] == 0)
                        return false;
                    freq[mini+i]--;
                    if(freq[mini+i] == 0)
                        freq.erase(mini+i);
                }
            }
            return true;
        }
        ```
    - TC: $O(nlogn)$
    - SC: $O(n)$
