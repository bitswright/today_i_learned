# Count Number of Nice Subarrays (LC#1248)

Given an array of integers `nums` and an integer `k`. A continuous subarray is called nice if there are `k` odd numbers on it.

Return the number of nice sub-arrays.

## Solution

- Brute force approach: 
    - Find all the subarrays and count the number of odd elements in them, if they are exactly `k` increment count. Return the final count.
    - TC: $O(n^3)$
    - SC: $O(1)$
- Slight improvement:
    - Instead of finding all the subarrays, we can fix `l` and then keep on tracking the number of odd elements by expanding `r`. Once, it reaches `k` we will start incrementing the count. But once, it exceeds `k`, we will break and increment `l` and repeat the same process.
    - TC: $O(n^2)$
    - SC: $O(1)$
- Using Sliding Window:
    - Sliding window can be used here because contiguous subarrays are to be found.
    - Count of subarrays is required.
    - Constraint: exactly `k`
        - Prefix trick: Exactly K â†’ AtMost(K) - AtMost(K-1))
    - Hence, we need to find, count of subarrays with atmost `k` odd numbers and atmost `k-1` odd numbers, then we just need to return difference of count of these two subarrays set.
        - We are taking the difference because atmost `k` set has all the subarrays with odd count as 0, 1, 2, ..., `k`. And atmost `k-1` has all subarrays with odd count as 0, 1, 2, ..., `k-1`.
        - So, we are just removing the count of subarrays with odd numbers < `k`, and keeping subarrays with exactly `k` odd numbers.
    - Add `r - l + 1` to count of subarrays in state because all the subarrays will satisfy the atmost `k` constraint.
    - Code:
        ```cpp
        int atmostK(vector<int>& nums, int n, int k) {
            int subarraysCount = 0;
            int l = 0, r = 0;
            int odd = 0; //state
            while(r < n) {
                // consider current element at `r` (grow)
                if(nums[r] % 2) odd++;
                r++;

                // shrink while condition is not again true
                while(odd > k) {
                    if(nums[l] % 2) odd--;
                    l++;
                }

                // update count
                subarraysCount += r - l + 1;
            }

            return subarraysCount;
        }

        int numberOfSubarrays(vector<int>& nums, int k) {
            int n = nums.size();
            return atmostK(nums, n, k) - atmostK(nums, n, k-1);
        }
        ```
    - TC: $O(n)$
    - SC: $O(1)$

## Notes

- Why exactly `k` won't work directly?
    - exactly `k` is not monotonic.
        - condition does not stay same.
        - i.e. condition could change from false to true then back again to false.
        - but sliding window says, 
            - grow while condition is true, and shrink once condition becomes false. 
        - if we won't shrink, the condition should stay false.